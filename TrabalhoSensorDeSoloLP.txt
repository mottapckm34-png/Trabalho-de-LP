#include <list>
#include <vector>
#include <algorithm>
#include <numeric>

#define SOIL_TEMP_PIN 4  
#define SOIL_HUMIDITY_PIN A0 
#define SALINITY_PIN A1 

struct DadosSolo {
  float temperaturaSolo;
  float umidadeSolo;
  float salinidade;
  unsigned long tempoColeta;

  String toSerialString() const {
    return String(temperaturaSolo, 1) + ";" + String(umidadeSolo, 1) + ";" + String(salinidade, 2);
  }
};

// Constantes de Tempo e Coleta
const unsigned long INTERVALO_COLETA = 15UL * 60UL * 1000UL; 
const int NUM_COLETAS_CICLO = 16; // 4 horas (16 * 15 min)

// Limites para Decisão de Irrigação 
const float LIMITE_UMIDADE_MIN = 30.0; 
const float LIMITE_TEMPERATURA_MEDIA_CRITICA = 30.0; 
const float LIMITE_SALINIDADE_MAX = 2.0;

// Variáveis de Controle
std::list<DadosSolo> dadosColetados;
unsigned long ultimaColeta = 0;
int contadorColetas = 0;
float ultimaTemperaturaMediaQuatroHoras = 0.0; 

// Funções de leitura (simuladas)
float lerTemperaturaSolo() {
  return 25.5; 
}

float lerUmidadeSolo() {
  int leituraSoloBruta = analogRead(SOIL_HUMIDITY_PIN);
  return map(leituraSoloBruta, 0, 1023, 0, 100); 
}

float lerSalinidade() {
  int leituraSal = analogRead(SALINITY_PIN);
  return ((float)leituraSal / 1023.0) * 5.0;
}

DadosSolo coletarDadosSolo() {
  DadosSolo dados;
  dados.temperaturaSolo = lerTemperaturaSolo();
  dados.umidadeSolo = lerUmidadeSolo();
  dados.salinidade = lerSalinidade();
  dados.tempoColeta = millis();
  return dados;
}

// Função de decisão de irrigação
void tomarDecisaoIrrigacao(const DadosSolo &dados) {
  bool deveIrrigar = false;
  String motivo = "Condições normais.";

  if (dados.umidadeSolo < LIMITE_UMIDADE_MIN) {
    deveIrrigar = true;
    motivo = "Umidade do solo baixa (" + String(dados.umidadeSolo, 1) + "%)";
  } 
  else if (ultimaTemperaturaMediaQuatroHoras > LIMITE_TEMPERATURA_MEDIA_CRITICA) {
    deveIrrigar = true;
    motivo = "Alta demanda hídrica (Temp Média 4h: " + String(ultimaTemperaturaMediaQuatroHoras, 1) + "°C)";
  } 
  else if (dados.salinidade > LIMITE_SALINIDADE_MAX) {
    if (dados.umidadeSolo < 55.0) {
      deveIrrigar = true;
      motivo = "Salinidade alta e solo seco. Irrigar para lixiviação.";
    } else {
      motivo = "Salinidade alta (" + String(dados.salinidade, 2) + " dS/m). Monitorar.";
    }
  }

 
  if (deveIrrigar) {
    Serial.print("[DECISAO] *IRRIGAR* ? ");
    Serial.println(motivo);
  } else {
    Serial.print("[DECISAO] NAO IRRIGAR ? ");
    Serial.println(motivo);
  }
}

// Exibe coleta individual
void apresentarColetaNoSerial(int contador, const DadosSolo &dados) {
  Serial.print("[COLETA ");
  if (contador < 10) Serial.print("0");
  Serial.print(contador);
  Serial.print("] Temp: "); Serial.print(dados.temperaturaSolo, 1);
  Serial.print(" | Umid: "); Serial.print(dados.umidadeSolo, 1);
  Serial.print(" | Sal: "); Serial.print(dados.salinidade, 2);
  Serial.print(" | ");
}

// Processa os dados e gera o relatório final
void processarEGerarRelatorio(std::list<DadosSolo> &listaDados) {
  if (listaDados.size() < 3) {
    Serial.println("\n[RELATORIO] Poucos dados para cálculo da média.");
    return;
  }

  // Coleta as temperaturas
  std::vector<float> temperaturas;
  for (auto &dado : listaDados)
    temperaturas.push_back(dado.temperaturaSolo);

  // Ordena e remove extremos
  std::sort(temperaturas.begin(), temperaturas.end());
  float menor = temperaturas.front();
  float maior = temperaturas.back();
  temperaturas.erase(temperaturas.begin());
  temperaturas.pop_back();

  // Calcula média
  float soma = std::accumulate(temperaturas.begin(), temperaturas.end(), 0.0);
  float media = soma / temperaturas.size();
  ultimaTemperaturaMediaQuatroHoras = media; 

  // Gera relatório
  Serial.println("\n");
  Serial.println("RELATORIO_FINAL_4_HORAS.TXT");
  Serial.println("\n");
  Serial.println("Dados_Processados_Temperatura_Solo");
  Serial.print("Data_Hora_Processamento: "); Serial.println(millis());
  Serial.print("Total_Coletas_Iniciais: "); Serial.println(listaDados.size());
  Serial.print("Valor_Menor_Removido: "); Serial.println(menor, 2);
  Serial.print("Valor_Maior_Removido: "); Serial.println(maior, 2);
  Serial.print("Media_Temperatura_Solo: "); Serial.println(media, 2);
  Serial.println("\n");
  Serial.println("Dados_Coletados (Temp;Umid;Sal)");
  
  for (auto &dado : listaDados) {
    Serial.println(dado.toSerialString());
  }

  Serial.println("\n");

  // Limpa para o próximo ciclo
  listaDados.clear();
  contadorColetas = 0;
}

void setup() {
  Serial.begin(9600);
  Serial.println("\n");
  Serial.println(" Coletor de Dados do Solo com Logica de Irrigacao ");
  Serial.println("\n");
  ultimaColeta = millis();
}

void loop() {
  unsigned long tempoAtual = millis();

  // Coleta a cada 15 minutos
  if (tempoAtual - ultimaColeta >= INTERVALO_COLETA) {
    DadosSolo dado = coletarDadosSolo();

    dadosColetados.push_back(dado);
    contadorColetas++;

    apresentarColetaNoSerial(contadorColetas, dado);
    tomarDecisaoIrrigacao(dado);

    if (contadorColetas >= NUM_COLETAS_CICLO) {
      processarEGerarRelatorio(dadosColetados);
    }

    ultimaColeta = tempoAtual;
  }
}
